<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>TypeScript4 中文文档</title>
    <meta name="generator" content="VuePress 1.8.2">
    <script>
        var _hmt = _hmt || [];
        (function() {
          var hm = document.createElement("script");
          hm.src = "https://hm.baidu.com/hm.js?82a3f80007c4e88c786f3602d0b8a215";
          var s = document.getElementsByTagName("script")[0]; 
          s.parentNode.insertBefore(hm, s);
        })();
        </script>
    <script>
        (function() {
	         if (location.href.indexOf('github.io') > -1 || location.href.indexOf('gitee.io') > -1) {
           		location.href = 'https://ts.yayujs.com';
           }
        })();
        </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/markdown-it/12.3.2/markdown-it.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/@docsearch/css@alpha" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@docsearch/js@alpha"></script>
    <meta name="description" content="TypeScript最新官方文档翻译,TypeScript中文手册,提供 TypeScript 从入门到进阶的系统学习教程">
    <meta name="keywords" content="TypeScript中文手册,TypeScript中文文档,TypeScript入门,TypeScrpt进阶">
    <meta name="baidu-site-verification" content="code-ODI5Ny1Ypq">
    <meta name="shenma-site-verification" content="437b0b24fde80c5638f0a422c8d8b9eb_1646289640">
    <meta name="sogou_site_verification" content="tkDYjAgVj3">
    
    <link rel="preload" href="/learn-typescript/assets/css/0.styles.538df46e.css" as="style"><link rel="preload" href="/learn-typescript/assets/js/app.4ea17abc.js" as="script"><link rel="preload" href="/learn-typescript/assets/js/3.ebbd5603.js" as="script"><link rel="preload" href="/learn-typescript/assets/js/1.af137d23.js" as="script"><link rel="preload" href="/learn-typescript/assets/js/14.fce36268.js" as="script"><link rel="prefetch" href="/learn-typescript/assets/js/10.34d1b24d.js"><link rel="prefetch" href="/learn-typescript/assets/js/11.22308e2c.js"><link rel="prefetch" href="/learn-typescript/assets/js/12.24227b7f.js"><link rel="prefetch" href="/learn-typescript/assets/js/13.5711ef55.js"><link rel="prefetch" href="/learn-typescript/assets/js/15.760c1ae0.js"><link rel="prefetch" href="/learn-typescript/assets/js/16.0bff8200.js"><link rel="prefetch" href="/learn-typescript/assets/js/17.f2cca8d4.js"><link rel="prefetch" href="/learn-typescript/assets/js/18.f188ae58.js"><link rel="prefetch" href="/learn-typescript/assets/js/19.5943124a.js"><link rel="prefetch" href="/learn-typescript/assets/js/20.0a1c7565.js"><link rel="prefetch" href="/learn-typescript/assets/js/21.1e8e6484.js"><link rel="prefetch" href="/learn-typescript/assets/js/22.54f512f7.js"><link rel="prefetch" href="/learn-typescript/assets/js/23.e1938187.js"><link rel="prefetch" href="/learn-typescript/assets/js/24.36da8f67.js"><link rel="prefetch" href="/learn-typescript/assets/js/25.a4fdc4f4.js"><link rel="prefetch" href="/learn-typescript/assets/js/26.8d2afc2e.js"><link rel="prefetch" href="/learn-typescript/assets/js/27.69126d20.js"><link rel="prefetch" href="/learn-typescript/assets/js/28.03139510.js"><link rel="prefetch" href="/learn-typescript/assets/js/29.c643b1cb.js"><link rel="prefetch" href="/learn-typescript/assets/js/30.d3289dbb.js"><link rel="prefetch" href="/learn-typescript/assets/js/31.944754f6.js"><link rel="prefetch" href="/learn-typescript/assets/js/32.d1d99c18.js"><link rel="prefetch" href="/learn-typescript/assets/js/33.30375215.js"><link rel="prefetch" href="/learn-typescript/assets/js/34.0793a4c4.js"><link rel="prefetch" href="/learn-typescript/assets/js/35.53b6d49b.js"><link rel="prefetch" href="/learn-typescript/assets/js/36.ac8bf61c.js"><link rel="prefetch" href="/learn-typescript/assets/js/37.fd5643e7.js"><link rel="prefetch" href="/learn-typescript/assets/js/38.cb01bbc7.js"><link rel="prefetch" href="/learn-typescript/assets/js/39.c0aa84fb.js"><link rel="prefetch" href="/learn-typescript/assets/js/4.91e6f4a0.js"><link rel="prefetch" href="/learn-typescript/assets/js/40.f6df32aa.js"><link rel="prefetch" href="/learn-typescript/assets/js/41.cfca785a.js"><link rel="prefetch" href="/learn-typescript/assets/js/42.cf887dd0.js"><link rel="prefetch" href="/learn-typescript/assets/js/43.44be6b1d.js"><link rel="prefetch" href="/learn-typescript/assets/js/44.08b69751.js"><link rel="prefetch" href="/learn-typescript/assets/js/5.1eb21207.js"><link rel="prefetch" href="/learn-typescript/assets/js/6.907bfa80.js"><link rel="prefetch" href="/learn-typescript/assets/js/7.20cd2429.js"><link rel="prefetch" href="/learn-typescript/assets/js/8.38a99588.js"><link rel="prefetch" href="/learn-typescript/assets/js/9.da1e0b9c.js">
    <link rel="stylesheet" href="/learn-typescript/assets/css/0.styles.538df46e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container" data-v-1aefc0b4><div data-v-1aefc0b4><div id="loader-wrapper" class="loading-wrapper" data-v-d48f4d20 data-v-1aefc0b4 data-v-1aefc0b4><div class="loader-main" data-v-d48f4d20><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div><div data-v-d48f4d20></div></div> <!----> <!----></div> <div class="password-shadow password-wrapper-out" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2>TypeScript4 中文文档</h3> <p class="description" data-v-25ba6db2 data-v-25ba6db2>TypeScript最新官方文档翻译,TypeScript中文手册,提供 TypeScript 从入门到进阶的系统学习教程</p> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div class="hide" data-v-1aefc0b4><header class="navbar" data-v-1aefc0b4><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn-typescript/" class="home-link router-link-active"><!----> <span class="site-name">TypeScript4 中文文档</span></a> <div class="links"><div class="color-picker"><a class="color-button"><i class="iconfont reco-color"></i></a> <div class="color-picker-menu" style="display:none;"><div class="mode-options"><h4 class="title">Choose mode</h4> <ul class="color-mode-options"><li class="dark">dark</li><li class="auto active">auto</li><li class="light">light</li></ul></div></div></div> <div class="search-box"><i class="iconfont reco-search"></i> <input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  冴羽的 JavaScript 博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/mqyqingfeng/learn-typescript" target="_blank" rel="noopener noreferrer" class="repo-link"><i class="iconfont reco-github"></i>
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask" data-v-1aefc0b4></div> <aside class="sidebar" data-v-1aefc0b4><div class="personal-info-wrapper" data-v-39576ba9 data-v-1aefc0b4><!----> <!----> <div class="num" data-v-39576ba9><div data-v-39576ba9><h3 data-v-39576ba9>3</h3> <h6 data-v-39576ba9>文章</h6></div> <div data-v-39576ba9><h3 data-v-39576ba9>0</h3> <h6 data-v-39576ba9>标签</h6></div></div> <ul class="social-links" data-v-39576ba9></ul> <hr data-v-39576ba9></div> <nav class="nav-links"><div class="nav-item"><a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer" class="nav-link external"><i class="undefined"></i>
  冴羽的 JavaScript 博客
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <a href="https://github.com/mqyqingfeng/learn-typescript" target="_blank" rel="noopener noreferrer" class="repo-link"><i class="iconfont reco-github"></i>
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><a href="/learn-typescript/" class="sidebar-heading clickable router-link-active"><span>欢迎</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/learn-typescript/handbook/TheBasics" class="sidebar-heading clickable open"><span>基础</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-typescript/handbook/TheBasics.html" class="sidebar-link">基础</a></li><li><a href="/learn-typescript/handbook/EverydayType.html" aria-current="page" class="active sidebar-link">常见类型</a></li><li><a href="/learn-typescript/handbook/Narrowing.html" class="sidebar-link">类型收窄</a></li><li><a href="/learn-typescript/handbook/MoreOnFunctions.html" class="sidebar-link">函数</a></li><li><a href="/learn-typescript/handbook/ObjectTypes.html" class="sidebar-link">对象类型</a></li><li><a href="/learn-typescript/handbook/Generics.html" class="sidebar-link">泛型</a></li><li><a href="/learn-typescript/handbook/KeyofTypeOperator.html" class="sidebar-link">keyof 操作符</a></li><li><a href="/learn-typescript/handbook/TypeofTypeOperator.html" class="sidebar-link">typeof 操作符</a></li><li><a href="/learn-typescript/handbook/IndexedAccessTypes.html" class="sidebar-link">索引访问类型</a></li><li><a href="/learn-typescript/handbook/ConditionalTypes.html" class="sidebar-link">条件类型</a></li><li><a href="/learn-typescript/handbook/MappedTypes.html" class="sidebar-link">映射类型</a></li><li><a href="/learn-typescript/handbook/TemplateLiteralTypes.html" class="sidebar-link">模板字面量类型</a></li><li><a href="/learn-typescript/handbook/Class.html" class="sidebar-link">类</a></li><li><a href="/learn-typescript/handbook/Modules.html" class="sidebar-link">模块</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/learn-typescript/reference/UtilityTypes" class="sidebar-heading clickable"><span>拓展</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/learn-typescript/advance/" class="sidebar-heading clickable"><span>进阶</span> <span class="arrow right"></span></a> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/learn-typescript/practice/" class="sidebar-heading clickable"><span>实战</span> <span class="arrow right"></span></a> <!----></section></li></ul> </aside> <div class="password-shadow password-wrapper-in" style="display:none;" data-v-25ba6db2 data-v-1aefc0b4><h3 class="title" data-v-25ba6db2 data-v-25ba6db2></h3> <!----> <label id="box" class="inputBox" data-v-25ba6db2 data-v-25ba6db2><input type="password" value="" data-v-25ba6db2> <span data-v-25ba6db2>Konck! Knock!</span> <button data-v-25ba6db2>OK</button></label> <div class="footer" data-v-25ba6db2 data-v-25ba6db2><span data-v-25ba6db2><i class="iconfont reco-theme" data-v-25ba6db2></i> <a target="blank" href="https://vuepress-theme-reco.recoluan.com" data-v-25ba6db2>vuePress-theme-reco</a></span> <span data-v-25ba6db2><i class="iconfont reco-copyright" data-v-25ba6db2></i> <a data-v-25ba6db2><!---->
            
          <!---->
          2022
        </a></span></div></div> <div data-v-1aefc0b4><main class="page"><section><div class="page-title"><h1 class="title"></h1> <div data-v-f875f3fc><!----> <!----> <!----> <!----></div></div> <div class="theme-reco-content content__default"><blockquote><p>本文译者<a href="https://github.com/mqyqingfeng" target="_blank" rel="noopener noreferrer">冴羽<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，感谢<a href="http://gaoyudong.cn/docs" target="_blank" rel="noopener noreferrer">宁玉<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="https://github.com/NameWjp" target="_blank" rel="noopener noreferrer">NameWjp<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="https://github.com/ximoThorn" target="_blank" rel="noopener noreferrer">ximoThorn<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>等人的<a href="http://www.ts.yayujs.com/learn-typescript/introduction/correctErrors.html" target="_blank" rel="noopener noreferrer">勘误<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，<a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html" target="_blank" rel="noopener noreferrer">原文<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <h2 id="常见类型-everyday-types"><a href="#常见类型-everyday-types" class="header-anchor">#</a> 常见类型（Everyday Types）</h2> <p>本章我们会讲解 JavaScript 中最常见的一些类型，以及对应的描述方式。注意本章内容并不详尽，后续的章节会讲解更多命名和使用类型的方式。</p> <p>类型可以出现在很多地方，不仅仅是在类型注解 (type annotations)中。我们不仅要学习类型本身，也要学习在什么地方使用这些类型产生新的结构。</p> <p>我们先复习下最基本和常见的类型，这些是构建更复杂类型的基础。</p> <h2 id="原始类型-string-number-和-boolean-the-primitives"><a href="#原始类型-string-number-和-boolean-the-primitives" class="header-anchor">#</a> 原始类型: <code>string</code>，<code>number</code> 和 <code>boolean</code>（The primitives）</h2> <p>JavaScript 有三个非常常用的<a href="https://developer.mozilla.org/en-US/docs/Glossary/Primitive" target="_blank" rel="noopener noreferrer">原始类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>：<code>string</code>，<code>number</code> 和 <code>boolean</code>，每一个类型在 TypeScript 中都有对应的类型。他们的名字跟你在 JavaScript 中使用 <code>typeof</code> 操作符得到的结果是一样的。</p> <ul><li><code>string</code> 表示字符串，比如 &quot;Hello, world&quot;</li> <li><code>number</code> 表示数字，比如 <code>42</code>，JavaScript 中没有 <code>int</code> 或者 <code>float</code>，所有的数字，类型都是 <code>number</code></li> <li><code>boolean</code> 表示布尔值，其实也就两个值： <code>true</code> 和 <code>false</code></li></ul> <blockquote><p>类型名 <code>String</code> ，<code>Number</code> 和 <code>Boolean</code> （首字母大写）也是合法的，但它们是一些非常少见的特殊内置类型。所以类型总是使用 <code>string</code> ，<code>number</code> 或者 <code>boolean</code> 。</p></blockquote> <h2 id="数组-array"><a href="#数组-array" class="header-anchor">#</a> 数组（Array）</h2> <p>声明一个类似于 <code>[1, 2, 3]</code> 的数组类型，你需要用到语法 <code>number[]</code>。这个语法可以适用于任何类型（举个例子，<code>string[]</code> 表示一个字符串数组）。你也可能看到这种写法 <code>Array&lt;number&gt;</code>，是一样的。我们会在泛型章节为大家介绍 <code>T&lt;U&gt;</code> 语法。</p> <blockquote><p>注意 <code>[number]</code> 和 <code>number[]</code> 表示不同的意思，参考<a href="https://www.typescriptlang.org/docs/handbook/2/objects.html#tuple-types" target="_blank" rel="noopener noreferrer">元组<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>章节</p></blockquote> <h2 id="any"><a href="#any" class="header-anchor">#</a> <code>any</code></h2> <p>TypeScript 有一个特殊的类型，<code>any</code>，当你不希望一个值导致类型检查错误的时候，就可以设置为 <code>any</code> 。</p> <p>当一个值是 <code>any</code> 类型的时候，你可以获取它的任意属性 (也会被转为 <code>any</code> 类型)，或者像函数一样调用它，把它赋值给一个任意类型的值，或者把任意类型的值赋值给它，再或者是其他语法正确的操作，都可以：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> obj<span class="token operator">:</span> <span class="token builtin">any</span> <span class="token operator">=</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// None of the following lines of code will throw compiler errors.</span>
<span class="token comment">// Using `any` disables all further type checking, and it is assumed </span>
<span class="token comment">// you know the environment better than TypeScript.</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">obj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
obj <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> n<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">=</span> obj<span class="token punctuation">;</span>
</code></pre></div><p>当你不想写一个长长的类型代码，仅仅想让 TypeScript 知道某段特定的代码是没有问题的，<code>any</code> 类型是很有用的。</p> <h3 id="noimplicitany"><a href="#noimplicitany" class="header-anchor">#</a> <code>noImplicitAny</code></h3> <p>如果你没有指定一个类型，TypeScript 也不能从上下文推断出它的类型，编译器就会默认设置为 <code>any</code> 类型。</p> <p>如果你总是想避免这种情况，毕竟 TypeScript 对 <code>any</code> 不做类型检查，你可以开启编译项 <a href="https://www.typescriptlang.org/tsconfig#noImplicitAny" target="_blank" rel="noopener noreferrer">noImplicitAny<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，当被隐式推断为 <code>any</code> 时，TypeScript 就会报错。</p> <h2 id="变量上的类型注解-type-annotations-on-variables"><a href="#变量上的类型注解-type-annotations-on-variables" class="header-anchor">#</a> 变量上的类型注解（Type Annotations on Variables）</h2> <p>当你使用 <code>const</code>、<code>var</code> 或 <code>let</code> 声明一个变量时，你可以选择性的添加一个类型注解，显式指定变量的类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> myName<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">=</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>TypeScript 并不使用“在左边进行类型声明”的形式，比如 <code>int x = 0</code>；类型注解往往跟在要被声明类型的内容后面。</p></blockquote> <p>不过大部分时候，这不是必须的。因为 TypeScript 会自动推断类型。举个例子，变量的类型可以基于初始值进行推断：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// No type annotation needed -- 'myName' inferred as type 'string'</span>
<span class="token keyword">let</span> myName <span class="token operator">=</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">;</span>
</code></pre></div><p>大部分时候，你不需要学习推断的规则。如果你刚开始使用，尝试尽可能少的使用类型注解。你也许会惊讶于，TypeScript 仅仅需要很少的内容就可以完全理解将要发生的事情。</p> <h2 id="函数-function"><a href="#函数-function" class="header-anchor">#</a> 函数（Function）</h2> <p>函数是 JavaScript 传递数据的主要方法。TypeScript 允许你指定函数的输入值和输出值的类型。</p> <h3 id="参数类型注解-parameter-type-annotations"><a href="#参数类型注解-parameter-type-annotations" class="header-anchor">#</a> 参数类型注解（Parameter Type Annotations）</h3> <p>当你声明一个函数的时候，你可以在每个参数后面添加一个类型注解，声明函数可以接受什么类型的参数。参数类型注解跟在参数名字后面：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// Parameter type annotation</span>
<span class="token keyword">function</span> <span class="token function">greet</span><span class="token punctuation">(</span>name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> name<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;!!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当参数有了类型注解的时候，TypeScript 便会检查函数的实参：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// Would be a runtime error if executed!</span>
<span class="token function">greet</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Argument of type 'number' is not assignable to parameter of type 'string'.</span>
</code></pre></div><blockquote><p>即便你对参数没有做类型注解，TypeScript 依然会检查传入参数的数量是否正确</p></blockquote> <h3 id="返回值类型注解-return-type-annotations"><a href="#返回值类型注解-return-type-annotations" class="header-anchor">#</a> 返回值类型注解（Return Type Annotations）</h3> <p>你也可以添加返回值的类型注解。返回值的类型注解跟在参数列表后面：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">getFavoriteNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">26</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>跟变量类型注解一样，你也不需要总是添加返回值类型注解，TypeScript 会基于它的 <code>return</code> 语句推断函数的返回类型。像这个例子中，类型注解写和没写都是一样的，但一些代码库会显式指定返回值的类型，可能是因为需要编写文档，或者阻止意外修改，亦或者仅仅是个人喜好。</p> <h3 id="匿名函数-anonymous-functions"><a href="#匿名函数-anonymous-functions" class="header-anchor">#</a> 匿名函数（Anonymous Functions）</h3> <p>匿名函数有一点不同于函数声明，当 TypeScript 知道一个匿名函数将被怎样调用的时候，匿名函数的参数会被自动的指定类型。</p> <p>这是一个例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// No type annotations here, but TypeScript can spot the bug</span>
<span class="token keyword">const</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Bob&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Eve&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
 
<span class="token comment">// Contextual typing for function</span>
names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toUppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// Contextual typing also applies to arrow functions</span>
names<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">toUppercase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Property 'toUppercase' does not exist on type 'string'. Did you mean 'toUpperCase'?</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>尽管参数 <code>s</code> 并没有添加类型注解，但 TypeScript 根据 <code>forEach</code> 函数的类型，以及传入的数组的类型，最后推断出了 <code>s</code> 的类型。</p> <p>这个过程被称为<strong>上下文推断（contextual typing）</strong>，因为正是从函数出现的上下文中推断出了它应该有的类型。</p> <p>跟推断规则一样，你也不需要学习它是如何发生的，只要知道，它确实存在并帮助你省掉某些并不需要的注解。后面，我们还会看到更多这样的例子，了解一个值出现的上下文是如何影响它的类型的。</p> <h2 id="对象类型-object-types"><a href="#对象类型-object-types" class="header-anchor">#</a> 对象类型（Object Types）</h2> <p>除了原始类型，最常见的类型就是对象类型了。定义一个对象类型，我们只需要简单的列出它的属性和对应的类型。</p> <p>举个例子：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// The parameter's type annotation is an object type</span>
<span class="token keyword">function</span> <span class="token function">printCoord</span><span class="token punctuation">(</span>pt<span class="token operator">:</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;The coordinate's x value is &quot;</span> <span class="token operator">+</span> pt<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;The coordinate's y value is &quot;</span> <span class="token operator">+</span> pt<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">printCoord</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">7</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这里，我们给参数添加了一个类型，该类型有两个属性, <code>x</code> 和 <code>y</code>，两个都是 <code>number</code> 类型。你可以使用 <code>,</code> 或者 <code>;</code>  分开属性，最后一个属性的分隔符加不加都行。</p> <p>每个属性对应的类型是可选的，如果你不指定，默认使用 <code>any</code> 类型。</p> <h3 id="可选属性-optional-properties"><a href="#可选属性-optional-properties" class="header-anchor">#</a> 可选属性（Optional Properties）</h3> <p>对象类型可以指定一些甚至所有的属性为可选的，你只需要在属性名后添加一个 <code>?</code> ：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">printName</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token punctuation">{</span> first<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> last<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token comment">// Both OK</span>
<span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">{</span> first<span class="token operator">:</span> <span class="token string">&quot;Bob&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printName</span><span class="token punctuation">(</span><span class="token punctuation">{</span> first<span class="token operator">:</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span> last<span class="token operator">:</span> <span class="token string">&quot;Alisson&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>在 JavaScript 中，如果你获取一个不存在的属性，你会得到一个 <code>undefined</code> 而不是一个运行时错误。因此，当你获取一个可选属性时，你需要在使用它前，先检查一下是否是 <code>undefined</code>。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">printName</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> <span class="token punctuation">{</span> first<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span> last<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Error - might crash if 'obj.last' wasn't provided!</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>last<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Object is possibly 'undefined'.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span>last <span class="token operator">!==</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// OK</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>last<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 
  <span class="token comment">// A safe alternative using modern JavaScript syntax:</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">.</span>last<span class="token operator">?.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="联合类型-union-types"><a href="#联合类型-union-types" class="header-anchor">#</a> 联合类型（Union Types）</h2> <p>TypeScript 类型系统允许你使用一系列的操作符，基于已经存在的类型构建新的类型。现在我们知道如何编写一些基础的类型了，是时候把它们组合在一起了。</p> <h3 id="定义一个联合类型-defining-a-union-type"><a href="#定义一个联合类型-defining-a-union-type" class="header-anchor">#</a> 定义一个联合类型（Defining a Union Type）</h3> <p>第一种组合类型的方式是使用联合类型，一个联合类型是由两个或者更多类型组成的类型，表示值可能是这些类型中的任意一个。这其中每个类型都是联合类型的<strong>成员（members）</strong>。</p> <p>让我们写一个函数，用来处理字符串或者数字：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">printId</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Your ID is: &quot;</span> <span class="token operator">+</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// OK</span>
<span class="token function">printId</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// OK</span>
<span class="token function">printId</span><span class="token punctuation">(</span><span class="token string">&quot;202&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Error</span>
<span class="token function">printId</span><span class="token punctuation">(</span><span class="token punctuation">{</span> myID<span class="token operator">:</span> <span class="token number">22342</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Argument of type '{ myID: number; }' is not assignable to parameter of type 'string | number'.</span>
<span class="token comment">// Type '{ myID: number; }' is not assignable to type 'number'.</span>
</code></pre></div><h3 id="使用联合类型-working-with-union-types"><a href="#使用联合类型-working-with-union-types" class="header-anchor">#</a> 使用联合类型（Working with Union Types）</h3> <p>提供一个符合联合类型的值很容易，你只需要提供符合任意一个联合成员类型的值即可。那么在你有了一个联合类型的值后，你该怎样使用它呢？</p> <p>TypeScript 会要求你做的事情，必须对每个联合的成员都是有效的。举个例子，如果你有一个联合类型 <code>string | number</code> , 你不能使用只存在 <code>string</code> 上的方法：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">printId</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Property 'toUpperCase' does not exist on type 'string | number'.</span>
    <span class="token comment">// Property 'toUpperCase' does not exist on type 'number'.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>解决方案是用代码收窄联合类型，就像你在 JavaScript 没有类型注解那样使用。当 TypeScript 可以根据代码的结构推断出一个更加具体的类型时，类型收窄就会出现。</p> <p>举个例子，TypeScript 知道，对一个 <code>string</code> 类型的值使用 <code>typeof</code> 会返回字符串 <code>&quot;string&quot;</code>：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">printId</span><span class="token punctuation">(</span>id<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> id <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// In this branch, id is of type 'string'</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Here, id is of type 'number'</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>再举一个例子，使用函数，比如 <code>Array.isArray</code>:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">welcomePeople</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token builtin">Array</span><span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Here: 'x' is 'string[]'</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; and &quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Here: 'x' is 'string'</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Welcome lone traveler &quot;</span> <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意在 <code>else</code>分支，我们并不需要做任何特殊的事情，如果 <code>x</code> 不是 <code>string[]</code>，那么它一定是 <code>string</code> .</p> <p>有时候，如果联合类型里的每个成员都有一个属性，举个例子，数组和字符串都有 <code>slice</code> 方法，你就可以直接使用这个属性，而不用做类型收窄：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// Return type is inferred as number[] | string</span>
<span class="token keyword">function</span> <span class="token function">getFirstThree</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>你可能很奇怪，为什么联合类型只能使用这些类型属性的交集，让我们举个例子，现在有两个房间，一个房间都是身高八尺戴帽子的人，另外一个房间则是会讲西班牙语戴帽子的人，合并这两个房间后，我们唯一知道的事情是：每一个人都戴着帽子。</p></blockquote> <h2 id="类型别名-type-aliases"><a href="#类型别名-type-aliases" class="header-anchor">#</a> 类型别名（Type Aliases）</h2> <p>我们已经学会在类型注解里直接使用对象类型和联合类型，这很方便，但有的时候，一个类型会被使用多次，此时我们更希望通过一个单独的名字来引用它。</p> <p>这就是类型别名（type alias）。所谓类型别名，顾名思义，一个可以指代任意类型的名字。类型别名的语法是：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Point</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
 
<span class="token comment">// Exactly the same as the earlier example</span>
<span class="token keyword">function</span> <span class="token function">printCoord</span><span class="token punctuation">(</span>pt<span class="token operator">:</span> Point<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;The coordinate's x value is &quot;</span> <span class="token operator">+</span> pt<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;The coordinate's y value is &quot;</span> <span class="token operator">+</span> pt<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token function">printCoord</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以使用类型别名给任意类型一个名字，举个例子，命名一个联合类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name"><span class="token constant">ID</span></span> <span class="token operator">=</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
</code></pre></div><p>注意别名是唯一的别名，你不能使用类型别名创建同一个类型的不同版本。当你使用类型别名的时候，它就跟你编写的类型是一样的。换句话说，代码看起来可能不合法，但对 TypeScript 依然是合法的，因为两个类型都是同一个类型的别名:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">UserInputSanitizedString</span> <span class="token operator">=</span> <span class="token builtin">string</span><span class="token punctuation">;</span>
 
<span class="token keyword">function</span> <span class="token function">sanitizeInput</span><span class="token punctuation">(</span>str<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> UserInputSanitizedString <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">sanitize</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// Create a sanitized input</span>
<span class="token keyword">let</span> userInput <span class="token operator">=</span> <span class="token function">sanitizeInput</span><span class="token punctuation">(</span><span class="token function">getInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// Can still be re-assigned with a string though</span>
userInput <span class="token operator">=</span> <span class="token string">&quot;new input&quot;</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="接口-interfaces"><a href="#接口-interfaces" class="header-anchor">#</a> 接口（Interfaces）</h2> <p>接口声明（interface declaration）是命名对象类型的另一种方式：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>
  x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
  y<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">function</span> <span class="token function">printCoord</span><span class="token punctuation">(</span>pt<span class="token operator">:</span> Point<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;The coordinate's x value is &quot;</span> <span class="token operator">+</span> pt<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;The coordinate's y value is &quot;</span> <span class="token operator">+</span> pt<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token function">printCoord</span><span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token number">100</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>就像我们在上节使用的类型别名，这个例子也同样可以运行，就跟我们使用了一个匿名对象类型一样。TypeScript 只关心传递给 <code>printCoord</code> 的值的结构（structure）——关心值是否有期望的属性。正是这种只关心类型的结构和能力的特性，我们才认为 TypeScript 是一个结构化（structurally）的类型系统。</p> <h3 id="类型别名和接口的不同"><a href="#类型别名和接口的不同" class="header-anchor">#</a> 类型别名和接口的不同</h3> <p>类型别名和接口非常相似，大部分时候，你可以任意选择使用。接口的几乎所有特性都可以在 <code>type</code> 中使用，两者最关键的差别在于类型别名本身无法添加新的属性，而接口是可以扩展的。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// Interface</span>
<span class="token comment">// 通过继承扩展类型</span>
<span class="token keyword">interface</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Bear</span> <span class="token keyword">extends</span> <span class="token class-name">Animal</span> <span class="token punctuation">{</span>
  honey<span class="token operator">:</span> <span class="token builtin">boolean</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> bear <span class="token operator">=</span> <span class="token function">getBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
bear<span class="token punctuation">.</span>name
bear<span class="token punctuation">.</span>honey
        
<span class="token comment">// Type</span>
<span class="token comment">// 通过交集扩展类型</span>
<span class="token keyword">type</span> <span class="token class-name">Animal</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  name<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Bear</span> <span class="token operator">=</span> Animal <span class="token operator">&amp;</span> <span class="token punctuation">{</span> 
  honey<span class="token operator">:</span> <span class="token builtin">boolean</span> 
<span class="token punctuation">}</span>

<span class="token keyword">const</span> bear <span class="token operator">=</span> <span class="token function">getBear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
bear<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
bear<span class="token punctuation">.</span>honey<span class="token punctuation">;</span>
</code></pre></div><div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// Interface</span>
<span class="token comment">// 对一个已经存在的接口添加新的字段</span>
<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">Window</span> <span class="token punctuation">{</span>
  ts<span class="token operator">:</span> TypeScriptAPI
<span class="token punctuation">}</span>

<span class="token keyword">const</span> src <span class="token operator">=</span> <span class="token string">'const a = &quot;Hello World&quot;'</span><span class="token punctuation">;</span>
window<span class="token punctuation">.</span>ts<span class="token punctuation">.</span><span class="token function">transpileModule</span><span class="token punctuation">(</span>src<span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
<span class="token comment">// Type</span>
<span class="token comment">// 创建后不能被改变</span>
<span class="token keyword">type</span> <span class="token class-name">Window</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  title<span class="token operator">:</span> <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> <span class="token class-name">Window</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  ts<span class="token operator">:</span> TypeScriptAPI
<span class="token punctuation">}</span>

<span class="token comment">// Error: Duplicate identifier 'Window'.</span>
</code></pre></div><p>在后续的章节里，你还会了解的更多。所以下面这些内容不能立刻理解也没有关系：</p> <ul><li>在 TypeScript 4.2 以前，<a href="https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA" target="_blank" rel="noopener noreferrer">类型别名的名字可能会出现在报错信息中<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，有时会替代等价的匿名类型（也许并不是期望的）。接口的名字则会始终出现在错误信息中。</li> <li>类型别名也许不会实现<a href="https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWZWhfYAjABMAMwALA+gbsVjoADqgjKESytQPxCHghAByXigYgBfr8LAsYj8aQMUASbDQcRSExCeCwFiIQh+AKfAYyBiQFgOPyIaikSGLQo0Zj-aazaY+dSaXjLDgAGXgAC9CKhDqAALxJaw2Ib2RzOISuDycLw+ImBYKQflCkWRRD2LXCw6JCxS1JCdJZHJ5RAFIbFJU8ADKC3WzEcnVZaGYE1ABpFnFOmsFhsil2uoHuzwArO9SmAAEIsSFrZB-GgAjjA5gtVN8VCEc1o1C4Q4AGlR2AwO1EsBQoAAbvB-gJ4HhPgB5aDwem-Ph1TCV3AEEirTp4ELtRbTPD4vwKjOfAuioSQHuDXBcnmgACC+eCONFEs73YAPGGZVT5cRyyhiHh7AAON7lsG3vBggB8XGV3l8-nVISOgghxoLq9i7io-AHsayRWGaFrlFauq2rg9qaIGQHwCBqChtKdgRo8TxRjeyB3o+7xAA" target="_blank" rel="noopener noreferrer">声明合并，但是接口可以<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>接口可能只会被用于<a href="https://www.typescriptlang.org/play?#code/PTAEAkFMCdIcgM6gC4HcD2pIA8CGBbABwBtIl0AzUAKBFAFcEBLAOwHMUBPQs0XFgCahWyGBVwBjMrTDJMAshOhMARpD4tQ6FQCtIE5DWoixk9QEEWAeV37kARlABvaqDegAbrmL1IALlAEZGV2agBfampkbgtrWwMAJlAAXmdXdy8ff0Dg1jZwyLoAVWZ2Lh5QVHUJflAlSFxROsY5fFAWAmk6CnRoLGwmILzQQmV8JmQmDzI-SOiKgGV+CaYAL0gBBdyy1KCQ-Pn1AFFplgA5enw1PtSWS+vCsAAVAAtB4QQWOEMKBuYVUiVCYvYQsUTQcRSBDGMGmKSgAAa-VEgiQe2GLgKQA" target="_blank" rel="noopener noreferrer">声明对象的形状，不能重命名原始类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>接口通过名字使用的时候，他们的名字会<a href="https://www.typescriptlang.org/play?#code/PTAEGEHsFsAcEsA2BTATqNrLusgzngIYDm+oA7koqIYuYQJ56gCueyoAUCKAC4AWHAHaFcoSADMaQ0PCG80EwgGNkALk6c5C1EtWgAsqOi1QAb06groEbjWg8vVHOKcAvpokshy3vEgyyMr8kEbQJogAFND2YREAlOaW1soBeJAoAHSIkMTRmbbI8e6aPMiZxJmgACqCGKhY6ABGyDnkFFQ0dIzMbBwCwqIccabcYLyQoKjIEmh8kwN8DLAc5PzwwbLMyAAeK77IACYaQSEjUWY2Q-YAjABMAMwALA+gbsVjNXW8yxySoAADaAA0CCaZbPh1XYqXgOIY0ZgmcK0AA0nyaLFhhGY8F4AHJmEJILCWsgZId4NNfIgGFdcIcUTVfgBlZTOWC8T7kAJ42G4eT+GS42QyRaYbCgXAEEguTzeXyCjDBSAAQSE8Ai0Xsl0K9kcziExDeiQs1lAqSE6SyOTy0AKQ2KHk4p1V6s1OuuoHuzwArMagA" target="_blank" rel="noopener noreferrer">总是出现在错误信息中，如果直接使用，则会出现原始结构<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>大部分时候，你可以根据个人喜好进行选择。TypeScript 会告诉你它是否需要其他方式的声明。如果你喜欢探索性的使用，那就使用 <code>interface</code> ，直到你需要用到 <code>type</code> 的特性。</p> <h2 id="类型断言-type-assertions"><a href="#类型断言-type-assertions" class="header-anchor">#</a> 类型断言（Type Assertions）</h2> <p>有的时候，你知道一个值的类型，但 TypeScript 不知道。</p> <p>举个例子，如果你使用 <code>document.getElementById</code>，TypeScript 仅仅知道它会返回一个 <code>HTMLElement</code>，但是你却知道，你要获取的是一个 <code>HTMLCanvasElement</code>。</p> <p>这时，你可以使用类型断言将其指定为一个更具体的类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> myCanvas <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;main_canvas&quot;</span><span class="token punctuation">)</span> <span class="token keyword">as</span> HTMLCanvasElement<span class="token punctuation">;</span>
</code></pre></div><p>就像类型注解一样，类型断言也会被编译器移除，并且不会影响任何运行时的行为。</p> <p>你也可以使用尖括号语法（注意不能在 <code>.tsx</code> 文件内使用），是等价的：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> myCanvas <span class="token operator">=</span> <span class="token operator">&lt;</span>HTMLCanvasElement<span class="token operator">&gt;</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">&quot;main_canvas&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>谨记：因为类型断言会在编译的时候被移除，所以运行时并不会有类型断言的检查，即使类型断言是错误的，也不会有异常或者 <code>null</code> 产生。</p></blockquote> <p>TypeScript 仅仅允许类型断言转换为一个更加具体或者更不具体的类型。这个规则可以阻止一些不可能的强制类型转换，比如：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span> <span class="token keyword">as</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token comment">// Conversion of type 'string' to type 'number' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first.</span>
</code></pre></div><p>有的时候，这条规则会显得非常保守，阻止了你原本有效的类型转换。如果发生了这种事情，你可以使用双重断言，先断言为 <code>any</code> （或者是 <code>unknown</code>），然后再断言为期望的类型：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token punctuation">(</span>expr <span class="token keyword">as</span> <span class="token builtin">any</span><span class="token punctuation">)</span> <span class="token keyword">as</span> <span class="token constant">T</span><span class="token punctuation">;</span>
</code></pre></div><h2 id="字面量类型-literal-types"><a href="#字面量类型-literal-types" class="header-anchor">#</a> 字面量类型（Literal Types）</h2> <p>除了常见的类型 <code>string</code> 和 <code>number</code> ，我们也可以将类型声明为更具体的数字或者字符串。</p> <p>众所周知，在 JavaScript 中，有多种方式可以声明变量。比如 <code>var</code> 和 <code>let</code> ，这种方式声明的变量后续可以被修改，还有 <code>const</code> ，这种方式声明的变量则不能被修改，这就会影响 TypeScript 为字面量创建类型。</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> changingString <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span>
changingString <span class="token operator">=</span> <span class="token string">&quot;Olá Mundo&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// Because `changingString` can represent any possible string, that</span>
<span class="token comment">// is how TypeScript describes it in the type system</span>
changingString<span class="token punctuation">;</span>
<span class="token comment">// let changingString: string</span>
</code></pre></div><div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> constantString <span class="token operator">=</span> <span class="token string">&quot;Hello World&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// Because `constantString` can only represent 1 possible string, it</span>
<span class="token comment">// has a literal type representation</span>
constantString<span class="token punctuation">;</span>
<span class="token comment">// const constantString: &quot;Hello World&quot;</span>
</code></pre></div><p>字面量类型本身并没有什么太大用：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">let</span> x<span class="token operator">:</span> <span class="token string">&quot;hello&quot;</span> <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// OK</span>
x <span class="token operator">=</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// ...</span>
x <span class="token operator">=</span> <span class="token string">&quot;howdy&quot;</span><span class="token punctuation">;</span>
<span class="token comment">// Type '&quot;howdy&quot;' is not assignable to type '&quot;hello&quot;'.</span>
</code></pre></div><p>如果结合联合类型，就显得有用多了。举个例子，当函数只能传入一些固定的字符串时：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">printText</span><span class="token punctuation">(</span>s<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> alignment<span class="token operator">:</span> <span class="token string">&quot;left&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;right&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;center&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token function">printText</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, world&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;left&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printText</span><span class="token punctuation">(</span><span class="token string">&quot;G'day, mate&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;centre&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Argument of type '&quot;centre&quot;' is not assignable to parameter of type '&quot;left&quot; | &quot;right&quot; | &quot;center&quot;'.</span>
</code></pre></div><p>数字字面量类型也是一样的：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">compare</span><span class="token punctuation">(</span>a<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> b<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">===</span> b <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> a <span class="token operator">&gt;</span> b <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当然了，你也可以跟非字面量类型联合：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Options</span> <span class="token punctuation">{</span>
  width<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">configure</span><span class="token punctuation">(</span>x<span class="token operator">:</span> Options <span class="token operator">|</span> <span class="token string">&quot;auto&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span>
<span class="token function">configure</span><span class="token punctuation">(</span><span class="token punctuation">{</span> width<span class="token operator">:</span> <span class="token number">100</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">configure</span><span class="token punctuation">(</span><span class="token string">&quot;auto&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">configure</span><span class="token punctuation">(</span><span class="token string">&quot;automatic&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Argument of type '&quot;automatic&quot;' is not assignable to parameter of type 'Options | &quot;auto&quot;'.</span>
</code></pre></div><p>还有一种字面量类型，布尔字面量。因为只有两种布尔字面量类型， <code>true</code> 和 <code>false</code> ，类型 <code>boolean</code> 实际上就是联合类型 <code>true | false</code> 的别名。</p> <h3 id="字面量推断-literal-inference"><a href="#字面量推断-literal-inference" class="header-anchor">#</a> 字面量推断（Literal Inference）</h3> <p>当你初始化变量为一个对象的时候，TypeScript 会假设这个对象的属性的值未来会被修改，举个例子，如果你写下这样的代码：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> counter<span class="token operator">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>someCondition<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  obj<span class="token punctuation">.</span>counter <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>TypeScript 并不会认为 <code>obj.counter</code> 之前是 <code>0</code>， 现在被赋值为 <code>1</code> 是一个错误。换句话说，<code>obj.counter</code> 必须是 <code>number</code> 类型，但不要求一定是 <code>0</code>，因为类型可以决定读写行为。</p> <p>这也同样应用于字符串:</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">declare</span> <span class="token keyword">function</span> <span class="token function">handleRequest</span><span class="token punctuation">(</span>url<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">,</span> method<span class="token operator">:</span> <span class="token string">&quot;GET&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;POST&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token keyword">void</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token punctuation">{</span> url<span class="token operator">:</span> <span class="token string">&quot;https://example.com&quot;</span><span class="token punctuation">,</span> method<span class="token operator">:</span> <span class="token string">&quot;GET&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">handleRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">,</span> req<span class="token punctuation">.</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Argument of type 'string' is not assignable to parameter of type '&quot;GET&quot; | &quot;POST&quot;'.</span>
</code></pre></div><p>在上面这个例子里，<code>req.method</code> 被推断为 <code>string</code> ，而不是 <code>&quot;GET&quot;</code>，因为在创建 <code>req</code> 和 调用 <code>handleRequest</code> 函数之间，可能还有其他的代码，或许会将 <code>req.method</code> 赋值一个新字符串比如 <code>&quot;Guess&quot;</code> 。所以 TypeScript 就报错了。</p> <p>有两种方式可以解决：</p> <ol><li>添加一个类型断言改变推断结果：</li></ol> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// Change 1:</span>
<span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token punctuation">{</span> url<span class="token operator">:</span> <span class="token string">&quot;https://example.com&quot;</span><span class="token punctuation">,</span> method<span class="token operator">:</span> <span class="token string">&quot;GET&quot;</span> <span class="token keyword">as</span> <span class="token string">&quot;GET&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// Change 2</span>
<span class="token function">handleRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">,</span> req<span class="token punctuation">.</span>method <span class="token keyword">as</span> <span class="token string">&quot;GET&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>修改 1 表示“我有意让 <code>req.method</code> 的类型为字面量类型 <code>&quot;GET&quot;</code>，这会阻止未来可能赋值为 <code>&quot;GUESS&quot;</code> 等字段”。修改 2 表示“我知道 <code>req.method</code> 的值是 <code>&quot;GET&quot;</code>”.</p> <ol start="2"><li>你也可以使用 <code>as const</code> 把整个对象转为一个类型字面量：</li></ol> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token punctuation">{</span> url<span class="token operator">:</span> <span class="token string">&quot;https://example.com&quot;</span><span class="token punctuation">,</span> method<span class="token operator">:</span> <span class="token string">&quot;GET&quot;</span> <span class="token punctuation">}</span> <span class="token keyword">as</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token function">handleRequest</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span>url<span class="token punctuation">,</span> req<span class="token punctuation">.</span>method<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>as const</code> 效果跟 <code>const</code> 类似，但是对类型系统而言，它可以确保所有的属性都被赋予一个字面量类型，而不是一个更通用的类型比如 <code>string</code> 或者 <code>number</code> 。</p> <h2 id="null-和-undefined"><a href="#null-和-undefined" class="header-anchor">#</a> <code>null</code> 和 <code>undefined</code></h2> <p>JavaScript 有两个原始类型的值，用于表示空缺或者未初始化，他们分别是 <code>null</code> 和 <code>undefined</code> 。</p> <p>TypeScript 有两个对应的同名类型。它们的行为取决于是否打开了 <a href="https://www.typescriptlang.org/tsconfig#strictNullChecks" target="_blank" rel="noopener noreferrer">strictNullChecks<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 选项。</p> <h3 id="strictnullchecks-关闭"><a href="#strictnullchecks-关闭" class="header-anchor">#</a> <code>strictNullChecks</code> 关闭</h3> <p>当 <a href="https://www.typescriptlang.org/tsconfig#strictNullChecks" target="_blank" rel="noopener noreferrer">strictNullChecks<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 选项关闭的时候，如果一个值可能是 <code>null</code> 或者 <code>undefined</code>，它依然可以被正确的访问，或者被赋值给任意类型的属性。这有点类似于没有空值检查的语言 (比如 C# ，Java) 。这些检查的缺少，是导致 bug 的主要源头，所以我们始终推荐开发者开启 <a href="https://www.typescriptlang.org/tsconfig#strictNullChecks" target="_blank" rel="noopener noreferrer">strictNullChecks<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 选项。</p> <h3 id="strictnullchecks-打开"><a href="#strictnullchecks-打开" class="header-anchor">#</a> <code>strictNullChecks</code> 打开</h3> <p>当 <a href="https://www.typescriptlang.org/tsconfig#strictNullChecks" target="_blank" rel="noopener noreferrer">strictNullChecks<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 选项打开的时候，如果一个值可能是 <code>null</code> 或者 <code>undefined</code>，你需要在用它的方法或者属性之前，先检查这些值，就像用可选的属性之前，先检查一下 是否是 <code>undefined</code> ，我们也可以使用类型收窄（narrowing）检查值是否是 <code>null</code>：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>x<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// do nothing</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;Hello, &quot;</span> <span class="token operator">+</span> x<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="非空断言操作符-后缀-non-null-assertion-operator"><a href="#非空断言操作符-后缀-non-null-assertion-operator" class="header-anchor">#</a> 非空断言操作符（后缀 <code>!</code>）(Non-null Assertion Operator)</h2> <p>TypeScript 提供了一个特殊的语法，可以在不做任何检查的情况下，从类型中移除 <code>null</code> 和 <code>undefined</code>，这就是在任意表达式后面写上 <code>!</code>  ，这是一个有效的类型断言，表示它的值不可能是 <code>null</code> 或者 <code>undefined</code>：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">function</span> <span class="token function">liveDangerously</span><span class="token punctuation">(</span>x<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">number</span> <span class="token operator">|</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// No error</span>
  <span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token operator">!</span><span class="token punctuation">.</span><span class="token function">toFixed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>就像其他的类型断言，这也不会更改任何运行时的行为。重要的事情说一遍，只有当你明确的知道这个值不可能是 <code>null</code> 或者 <code>undefined</code> 时才使用 <code>!</code> 。</p> <h2 id="枚举-enums"><a href="#枚举-enums" class="header-anchor">#</a> 枚举（Enums）</h2> <p>枚举是 TypeScript 添加的新特性，用于描述一个值可能是多个常量中的一个。不同于大部分的 TypeScript 特性，这并不是一个类型层面的增量，而是会添加到语言和运行时。因为如此，你应该了解下这个特性。但是可以等一等再用，除非你确定要使用它。你可以在<a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener noreferrer">枚举类型<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>页面了解更多的信息。</p> <h2 id="不常见的原始类型-less-common-primitives"><a href="#不常见的原始类型-less-common-primitives" class="header-anchor">#</a> 不常见的原始类型（Less Common Primitives）</h2> <p>我们提一下在 JavaScript 中剩余的一些原始类型。但是我们并不会深入讲解。</p> <h3 id="bigint"><a href="#bigint" class="header-anchor">#</a> bigInt</h3> <p>ES2020 引入原始类型 <code>BigInt</code>，用于表示非常大的整数：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token comment">// Creating a bigint via the BigInt function</span>
<span class="token keyword">const</span> oneHundred<span class="token operator">:</span> bigint <span class="token operator">=</span> <span class="token function">BigInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token comment">// Creating a BigInt via the literal syntax</span>
<span class="token keyword">const</span> anotherHundred<span class="token operator">:</span> bigint <span class="token operator">=</span> <span class="token number">100n</span><span class="token punctuation">;</span>
</code></pre></div><p>你可以在 [TypeScript 3.2 的发布日志](the TypeScript 3.2 release notes)中了解更多信息。</p> <h3 id="symbol"><a href="#symbol" class="header-anchor">#</a> symbol</h3> <p>这也是 JavaScript 中的一个原始类型，通过函数 <code>Symbol()</code>，我们可以创建一个全局唯一的引用：</p> <div class="language-typescript extra-class"><pre class="language-typescript"><code><span class="token keyword">const</span> firstName <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> secondName <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">&quot;name&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
<span class="token keyword">if</span> <span class="token punctuation">(</span>firstName <span class="token operator">===</span> secondName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// This condition will always return 'false' since the types 'typeof firstName' and 'typeof secondName' have no overlap.</span>
  <span class="token comment">// Can't ever happen</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可以在 <a href="https://www.typescriptlang.org/docs/handbook/symbols.html" target="_blank" rel="noopener noreferrer">Symbol 页面<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>了解更多的信息。</p></div></section> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">2022/1/6</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/learn-typescript/handbook/TheBasics.html" class="prev">
            基础
          </a></span> <span class="next"><a href="/learn-typescript/handbook/Narrowing.html">
            类型收窄
          </a></span></p></div> <div class="comments-wrapper"><!----></div> <ul class="side-bar sub-sidebar-wrapper" style="width:12rem;" data-v-cb1513f6><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#常见类型-everyday-types" class="sidebar-link reco-side-常见类型-everyday-types" data-v-cb1513f6>常见类型（Everyday Types）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#原始类型-string-number-和-boolean-the-primitives" class="sidebar-link reco-side-原始类型-string-number-和-boolean-the-primitives" data-v-cb1513f6>原始类型: string，number 和 boolean（The primitives）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#数组-array" class="sidebar-link reco-side-数组-array" data-v-cb1513f6>数组（Array）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#any" class="sidebar-link reco-side-any" data-v-cb1513f6>any</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#noimplicitany" class="sidebar-link reco-side-noimplicitany" data-v-cb1513f6>noImplicitAny</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#变量上的类型注解-type-annotations-on-variables" class="sidebar-link reco-side-变量上的类型注解-type-annotations-on-variables" data-v-cb1513f6>变量上的类型注解（Type Annotations on Variables）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#函数-function" class="sidebar-link reco-side-函数-function" data-v-cb1513f6>函数（Function）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#参数类型注解-parameter-type-annotations" class="sidebar-link reco-side-参数类型注解-parameter-type-annotations" data-v-cb1513f6>参数类型注解（Parameter Type Annotations）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#返回值类型注解-return-type-annotations" class="sidebar-link reco-side-返回值类型注解-return-type-annotations" data-v-cb1513f6>返回值类型注解（Return Type Annotations）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#匿名函数-anonymous-functions" class="sidebar-link reco-side-匿名函数-anonymous-functions" data-v-cb1513f6>匿名函数（Anonymous Functions）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#对象类型-object-types" class="sidebar-link reco-side-对象类型-object-types" data-v-cb1513f6>对象类型（Object Types）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#可选属性-optional-properties" class="sidebar-link reco-side-可选属性-optional-properties" data-v-cb1513f6>可选属性（Optional Properties）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#联合类型-union-types" class="sidebar-link reco-side-联合类型-union-types" data-v-cb1513f6>联合类型（Union Types）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#定义一个联合类型-defining-a-union-type" class="sidebar-link reco-side-定义一个联合类型-defining-a-union-type" data-v-cb1513f6>定义一个联合类型（Defining a Union Type）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#使用联合类型-working-with-union-types" class="sidebar-link reco-side-使用联合类型-working-with-union-types" data-v-cb1513f6>使用联合类型（Working with Union Types）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#类型别名-type-aliases" class="sidebar-link reco-side-类型别名-type-aliases" data-v-cb1513f6>类型别名（Type Aliases）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#接口-interfaces" class="sidebar-link reco-side-接口-interfaces" data-v-cb1513f6>接口（Interfaces）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#类型别名和接口的不同" class="sidebar-link reco-side-类型别名和接口的不同" data-v-cb1513f6>类型别名和接口的不同</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#类型断言-type-assertions" class="sidebar-link reco-side-类型断言-type-assertions" data-v-cb1513f6>类型断言（Type Assertions）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#字面量类型-literal-types" class="sidebar-link reco-side-字面量类型-literal-types" data-v-cb1513f6>字面量类型（Literal Types）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#字面量推断-literal-inference" class="sidebar-link reco-side-字面量推断-literal-inference" data-v-cb1513f6>字面量推断（Literal Inference）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#null-和-undefined" class="sidebar-link reco-side-null-和-undefined" data-v-cb1513f6>null 和 undefined</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#strictnullchecks-关闭" class="sidebar-link reco-side-strictnullchecks-关闭" data-v-cb1513f6>strictNullChecks 关闭</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#strictnullchecks-打开" class="sidebar-link reco-side-strictnullchecks-打开" data-v-cb1513f6>strictNullChecks 打开</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#非空断言操作符-后缀-non-null-assertion-operator" class="sidebar-link reco-side-非空断言操作符-后缀-non-null-assertion-operator" data-v-cb1513f6>非空断言操作符（后缀 !）(Non-null Assertion Operator)</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#枚举-enums" class="sidebar-link reco-side-枚举-enums" data-v-cb1513f6>枚举（Enums）</a></li><li class="level-2" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#不常见的原始类型-less-common-primitives" class="sidebar-link reco-side-不常见的原始类型-less-common-primitives" data-v-cb1513f6>不常见的原始类型（Less Common Primitives）</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#bigint" class="sidebar-link reco-side-bigint" data-v-cb1513f6>bigInt</a></li><li class="level-3" data-v-cb1513f6><a href="/learn-typescript/handbook/EverydayType.html#symbol" class="sidebar-link reco-side-symbol" data-v-cb1513f6>symbol</a></li></ul></main> <!----></div></div></div></div><div class="global-ui"><div class="back-to-ceiling" style="right:1rem;bottom:6rem;width:2.5rem;height:2.5rem;border-radius:.25rem;line-height:2.5rem;display:none;" data-v-c6073ba8 data-v-c6073ba8><svg t="1574745035067" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5404" class="icon" data-v-c6073ba8><path d="M526.60727968 10.90185116a27.675 27.675 0 0 0-29.21455937 0c-131.36607665 82.28402758-218.69155461 228.01873535-218.69155402 394.07834331a462.20625001 462.20625001 0 0 0 5.36959153 69.94390903c1.00431239 6.55289093-0.34802892 13.13561351-3.76865779 18.80351572-32.63518765 54.11355614-51.75690182 118.55860487-51.7569018 187.94566865a371.06718723 371.06718723 0 0 0 11.50484808 91.98906777c6.53300375 25.50556257 41.68394495 28.14064038 52.69160883 4.22606766 17.37162448-37.73630017 42.14135425-72.50938081 72.80769204-103.21549295 2.18761121 3.04276886 4.15646224 6.24463696 6.40373557 9.22774369a1871.4375 1871.4375 0 0 0 140.04691725 5.34970492 1866.36093723 1866.36093723 0 0 0 140.04691723-5.34970492c2.24727335-2.98310674 4.21612437-6.18497483 6.3937923-9.2178004 30.66633723 30.70611158 55.4360664 65.4791928 72.80769147 103.21549355 11.00766384 23.91457269 46.15860503 21.27949489 52.69160879-4.22606768a371.15156223 371.15156223 0 0 0 11.514792-91.99901164c0-69.36717486-19.13165746-133.82216804-51.75690182-187.92578088-3.42062944-5.66790279-4.76302748-12.26056868-3.76865837-18.80351632a462.20625001 462.20625001 0 0 0 5.36959269-69.943909c-0.00994388-166.08943902-87.32547796-311.81420293-218.6915546-394.09823051zM605.93803103 357.87693858a93.93749974 93.93749974 0 1 1-187.89594924 6.1e-7 93.93749974 93.93749974 0 0 1 187.89594924-6.1e-7z" p-id="5405" data-v-c6073ba8></path><path d="M429.50777625 765.63860547C429.50777625 803.39355007 466.44236686 1000.39046097 512.00932183 1000.39046097c45.56695499 0 82.4922232-197.00623328 82.5015456-234.7518555 0-37.75494459-36.9345906-68.35043303-82.4922232-68.34111062-45.57627738-0.00932239-82.52019037 30.59548842-82.51086798 68.34111062z" p-id="5406" data-v-c6073ba8></path></svg></div></div></div>
    <script src="/learn-typescript/assets/js/app.4ea17abc.js" defer></script><script src="/learn-typescript/assets/js/3.ebbd5603.js" defer></script><script src="/learn-typescript/assets/js/1.af137d23.js" defer></script><script src="/learn-typescript/assets/js/14.fce36268.js" defer></script>
  </body>
</html>
